<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>LucidDbSubqueries - LucidDB Wiki</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.18.1" />
<link rel="shortcut icon" href="/wiki/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="LucidDB Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://luciddb.org/wiki/api.php?action=rsd" />
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
<link rel="alternate" type="application/atom+xml" title="LucidDB Wiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="/wiki/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.monobook&amp;only=styles&amp;skin=monobook&amp;*" />
<!--[if lt IE 5.5000]><link rel="stylesheet" href="/wiki/skins/monobook/IE50Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 5.5000]><link rel="stylesheet" href="/wiki/skins/monobook/IE55Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 6]><link rel="stylesheet" href="/wiki/skins/monobook/IE60Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/wiki/skins/monobook/IE70Fixes.css?303" media="screen" /><![endif]--><meta name="ResourceLoaderDynamicStyles" content="" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: wikidb:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */
</style>
<script src="/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=monobook&amp;*"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "LucidDbSubqueries", "wgTitle": "LucidDbSubqueries", "wgCurRevisionId": 7131, "wgArticleId": 1667, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": [], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-LucidDbSubqueries action-view skin-monobook">
<div id="globalWrapper">
<div id="column-content"><div id="content">
	<a id="top"></a>
	
	<h1 id="firstHeading" class="firstHeading">LucidDbSubqueries</h1>
	<div id="bodyContent">
		<div id="siteSub">From LucidDB Wiki</div>
		<div id="contentSub"></div>
		<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>
		<!-- start content -->
<div lang="en" dir="ltr" class="mw-content-ltr"><p><b>Supported Usage of Subqueries in LucidDB</b>
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Types_of_Subqueries"><span class="tocnumber">2</span> <span class="toctext">Types of Subqueries</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Correlated_Subquery"><span class="tocnumber">2.1</span> <span class="toctext">Correlated Subquery</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Scalar_Subquery"><span class="tocnumber">2.2</span> <span class="toctext">Scalar Subquery</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Table_Subquery"><span class="tocnumber">2.3</span> <span class="toctext">Table Subquery</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Usages_of_Subqueries"><span class="tocnumber">3</span> <span class="toctext">Usages of Subqueries</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#Predicates"><span class="tocnumber">3.1</span> <span class="toctext">Predicates</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Select_List"><span class="tocnumber">3.2</span> <span class="toctext">Select List</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Aggregates"><span class="tocnumber">3.3</span> <span class="toctext">Aggregates</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Lateral_Derived_Table"><span class="tocnumber">3.4</span> <span class="toctext">Lateral Derived Table</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#LucidDB_Subquery_Rewrite"><span class="tocnumber">4</span> <span class="toctext">LucidDB Subquery Rewrite</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Decorrelation"><span class="tocnumber">4.1</span> <span class="toctext">Decorrelation</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#More_Complex_Examples"><span class="tocnumber">4.2</span> <span class="toctext">More Complex Examples</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#NULL_Semantics"><span class="tocnumber">4.3</span> <span class="toctext">NULL Semantics</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Reducing_Non-Correlated_Subqueries_To_Constants"><span class="tocnumber">4.4</span> <span class="toctext">Reducing Non-Correlated Subqueries To Constants</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Enforcing_Scalar_Subquery_During_Execution"><span class="tocnumber">4.5</span> <span class="toctext">Enforcing Scalar Subquery During Execution</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="#Efficient_Decorrelation"><span class="tocnumber">5</span> <span class="toctext">Efficient Decorrelation</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Scalar_Subquery_2"><span class="tocnumber">5.1</span> <span class="toctext">Scalar Subquery</span></a>
<ul>
<li class="toclevel-3 tocsection-19"><a href="#Correlation_in_Projection"><span class="tocnumber">5.1.1</span> <span class="toctext">Correlation in Projection</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Correlation_in_Join_Filter"><span class="tocnumber">5.1.2</span> <span class="toctext">Correlation in Join Filter</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21"><a href="#Scalar_Subquery_with_Aggregates"><span class="tocnumber">5.2</span> <span class="toctext">Scalar Subquery with Aggregates</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#Correlation_in_Inputs_to_Aggregates"><span class="tocnumber">5.2.1</span> <span class="toctext">Correlation in Inputs to Aggregates</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Correlation_in_Join_Filter_2"><span class="tocnumber">5.2.2</span> <span class="toctext">Correlation in Join Filter</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#Summary_of_LucidDB_Subquery_Support"><span class="tocnumber">6</span> <span class="toctext">Summary of LucidDB Subquery Support</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#Future_Work"><span class="tocnumber">7</span> <span class="toctext">Future Work</span></a></li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Introduction">Introduction</span></h1>
<p>A subquery is a SELECT statement within another statement. With subquery, the user does not have to write complex joins to perform lookups between relations (or within the same relation). The SQL is also more readable. For example, "find the empno of the youngest employee" can be expressed as,
</p>
<pre>   Q1
   select e1.empno
   from emps e1
   where e1.age = (select min(e2.age) from emps e2);
</pre>
<p>Subqueries come in many flavors and can be used in different ways inside a query statement.
</p>
<h1> <span class="mw-headline" id="Types_of_Subqueries">Types of Subqueries</span></h1>
<h2> <span class="mw-headline" id="Correlated_Subquery">Correlated Subquery</span></h2>
<p>A correlated subquery, as opposed to uncorrelated subquery, is a subquery that references values from the outer query. For example, "find the empno of the youngest employee in his department" can be expressed by the following query,
</p>
<pre>   Q2
   select e1.empno
   from emps e1
   where e1.age = (select min(e2.age) from emps e2 where e2.deptno = e1.deptno);
</pre>
<h2> <span class="mw-headline" id="Scalar_Subquery">Scalar Subquery</span></h2>
<p>A scalar subquery has the property of returning only one value (i.e. one row of a single column). It needs to appear inside a pair of parenthesis. Scalar subqueries can also be correlated. For example, "list a employee's empno and the difference between his age and the average age in the department", can be written as this query,
</p>
<pre>   Q3
   select e1.empno,
              (e1.age - (select avg(age) from emps e2 where e2.deptno = e1.deptno))
   from emps e1;
</pre>
<h2> <span class="mw-headline" id="Table_Subquery">Table Subquery</span></h2>
<p>A table subquery can return multiple rows, each having multiple columns.
</p>
<h1> <span class="mw-headline" id="Usages_of_Subqueries">Usages of Subqueries</span></h1>
<p>Subqueries can be used in many places inside a SQL statement, for example, in predicates, in the select list, in lateral table constructs and as operand to row operaters like aggregates.
</p>
<h2> <span class="mw-headline" id="Predicates">Predicates</span></h2>
<p>Subqueries are used a lot in predicates, either directly in a predicate or via operators over the subquery.
</p><p>A scalar subquery can be used in a predicate where a value is allowed. For example, " find all employees whose department name is not null",
</p>
<pre>   Q4
   select empno
   from  emps
   where (select name from depts where depts.deptno = emps.deptno) is not null;
</pre>
<p>A table subquery can appear in predicates that compare a value against a set of values(IN/NOT IN, ANY, ALL, SOME), or predicates that check the property of a set of values (EXISTS/NOT EXISTS). For example, "find all employees who work for departments listed in depts table":
</p>
<pre>   Q5
   select name, empno
   from emps
   where deptno in (select deptno from depts);
</pre>
<p>This question can also be answered by the following query,
</p>
<pre>   Q6
   select name, empno
   from emps
   where exists (select deptno from depts where deptno = emps.deptno);
</pre>
<h2> <span class="mw-headline" id="Select_List">Select List</span></h2>
<p>Scalar subqueries can also appear in select list. For example, "list all the departments and the youngest worker's age in that department",
</p>
<pre>   Q7
   select deptno, (select min(age) from emps where emps.deptno = depts.deptno)
   from depts;
</pre>
<h2> <span class="mw-headline" id="Aggregates">Aggregates</span></h2>
<p>Mondrian can generate subqueries as operands to aggregates. For example, "find the ratio of an employee's age to the sum of ages of all employees in his department". (Note that the double-parentheses are required by the standard:  outer pair for sum arguments, and inner pair for scalar subquery):
</p>
<pre>   Q8
   select e1.empno, e1.age/sum((select e2.age from emps e2 where e1.deptno = e2.deptno))
   from emps e1;
</pre>
<h2> <span class="mw-headline" id="Lateral_Derived_Table">Lateral Derived Table</span></h2>
<p>A Lateral Derived Table is used like an inlined view when a subquery is encapsulated by the LATERAL keyword. It differs from inlined views in that it can reference expressions produced by relations left, or earlier in join order, to the subquery.  For example,
</p>
<pre>   Q9
   select emps.empno, d.deptno
   from emps, lateral (select * from depts where depts.deptno = emps.deptno) as d;
</pre>
<h1> <span class="mw-headline" id="LucidDB_Subquery_Rewrite">LucidDB Subquery Rewrite</span></h1>
<p>LucidDB does not have the concept of using a separate RelNode tree (the "nested cursor" concept) to evaluate an expression. Subqueries are always evaluated as part of the same RelNode tree as the enclosing query. Join is used to connect the two RelNode trees. Join methods like hash join can be more efficient because the inputs are read only once. Furthermore, if there is any correlation, i.e. the left input of the join provides values to the right input, a join with the ability to restart the right input and pass values from the left input to the right is required. LucidDB does not have support for this type of Join. (Cartesian product cannot pass values and Hash Join does not restart the right input). Correlated subqueries will need to be decorrelated before evaluation.
</p>
<h2> <span class="mw-headline" id="Decorrelation">Decorrelation</span></h2>
<p>While translating SQL representation to logical representation, subqueries are rewritten into joins  and filters if possible. For example,  Q5 is equivalent to the following query.
</p>
<pre>   Q10
   select emps.name, emps.empno
   from emps inner join (select distinct deptno from depts) d
   on emps.deptno = d.deptno;
</pre>
<p>Notice the distinct aggregate is added because IN tests membership in a set so the equivalent join cannot have duplicates in the right input.
In LucidDB, this query will generate the following physical plan. The distinct aggregate is folded into the Hash Join (and makes it a LeftSemi join which removes duplicates).
</p>
<pre>
    FennelToIteratorConverter                               
        FennelReshapeRel(...)
            LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[LEFTSEMI])
                FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]],...)
                FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]],...)
</pre>
<h2> <span class="mw-headline" id="More_Complex_Examples">More Complex Examples</span></h2>
<p>Subquery decorrelation is the process of transforming the above logical representation into an equivalent form using only joins and filters. Before decorrelation, the logical representation looks like this for Q6:
</p>
<pre>
    ProjectRel(NAME=[$1], EMPNO=[$0])
        FilterRel(condition=[IS TRUE($10)])
           CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2]])
               TableAccessRel(table=[[LOCALDB, SALES, EMPS]])
               AggregateRel(groupCount=[0], agg#0=[MIN(0)])
                   ProjectRel($f0=[true])
                       ProjectRel(DEPTNO=[$0])
                           FilterRel(condition=[=($0, $cor0.DEPTNO)])
                              TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])
</pre>
<p>In LucidDB, decorrelation is done by joining the subquery with value generators that provide the correlated input to the subquery. The result of decorrelation is the logical representation of this equivalent query (for Q6).
</p>
<pre>   Q11
   select from emp
                       left outer join
                       (select G.deptno, MIN(G.indicator) as indicator
                        from (select depts.deptno as deptno, TRUE as indicator
                                  from depts inner join
                                           (select distinct depts from emps) G
                                  on depts.deptno = G.deptno)
                        group by G.deptno) T
   where T.indicator is true";
</pre>
<p>Note the MIN(G.indicator) in T is simply to produce a value TRUE for each group of G.deptno. The corresponding logical plan looks like this:
</p>
<pre>
    ProjectRel(NAME=[$1], EMPNO=[$0])
        FilterRel(condition=[IS TRUE($11)])
           JoinRel(condition=[=($2, $10)], joinType=[left])
              TableAccessRel(table=[[LOCALDB, SALES, EMPS]])
              AggregateRel(groupCount=[1], agg#0=[MIN(1)])
                   ProjectRel($f0=[$1], $f0=[$0])
                      ProjectRel($f0=[true], $f0=[$1])
                         ProjectRel(DEPTNO=[$0], $f0=[$2])
                             FilterRel(condition=[=($0, $2)])
                               JoinRel(condition=[true], joinType=[inner])
                                 TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])
                                 AggregateRel(groupCount=[1])
                                      ProjectRel($f0=[$2])
                                          TableAccessRel(table=[[LOCALDB, SALES, EMPS]])
</pre>
<p>The correlated logical plan is only available in the trace file (org.eigenbase.sql2rel.level=FINE). The decorrelated plan is also available via sqlline be issuing "explain plan without implementation" statement. Some of the ProjectRels in the plan will be optimized away (either pushed into the scan or combined) during physical plan generation. So the explain plan output actually has fewer operations:
</p>
<pre>
    FennelToIteratorConverter                                                                                                                                                                           
        FennelReshapeRel(projection=[[1, 0]], filterOp=[COMP_EQ], filterOrdinals=[[4]], filterTuple=[[true]], ...)
            LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[LEFT])                                                                                                                                            
                FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 1, 2]], ....)  
                LhxAggRel(groupCount=[1], agg#0=[MIN(1)])                                                                                                                                                     
                    IteratorToFennelConverter                                                                                                                                                                   
                      IterCalcRel(expr#0..1=[{inputs}], expr#2=[true], $f0=[$t1], $f0=[$t2])                                                                                                                    
                        FennelToIteratorConverter                                                                                                                                                               
                            LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])                                                                                                                         
                                FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], ...)
                                LhxAggRel(groupCount=[1])                                                                                                                                                           
                                    FennelRenameRel(fieldNames=[[$f0]])                                                                                                                                               
                                    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2]],...)
</pre>
<p>A subquery can itself contain other subqueries. The inner subquery can correlate to both the outer subquery and the main query, as in this example:
</p>
<pre>   Q12
   select name
   from emps
   where exists(select *
                from depts
                where depts.deptno &gt; emps.deptno or
                      exists (select *
                              from depts2
                              where depts.name = depts2.name
                                    and depts2.deptno &lt;&gt; emps.empno));
</pre>
<p>The decorrelated logical plan is quite complex in this case.  The hash lines below mark the subtree rooted at a certain join rel.
</p>
<pre>
    ProjectRel(NAME=[$1])
        FilterRel(condition=[IS TRUE($12)])
       --- JoinRel(condition=[AND(=($2, $11), =($0, $10))], joinType=[left])
       |      TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                  
       |      AggregateRel(groupCount=[2], agg#0=[MIN(2)])                                    
       |          ProjectRel($f00=[$1], $f01=[$2], $f0=[$0])                                    
       |             ProjectRel($f0=[true], $f00=[$2], $f01=[$3])                                
       |                 ProjectRel(DEPTNO=[$0], NAME=[$1], $f00=[$3], $f01=[$5])                  
       |                    FilterRel(condition=[OR(&gt;($0, $5), IS TRUE($4))])                       
       |                 ---- JoinRel(condition=[true], joinType=[inner])                           
       |                 |   --- JoinRel(condition=[=($1, $2)], joinType=[left])                     
       |                 |   |      TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                   
       |                 |   |      AggregateRel(groupCount=[2], agg#0=[MIN(2)])                      
       |                 |   |           ProjectRel($f0=[$1], $f00=[$2], $f0=[$0])                       
       |                 |   |               ProjectRel($f0=[true], $f0=[$2], $f00=[$3])                   
       |                 |   |                   ProjectRel(DEPTNO=[$0], NAME=[$1], $f0=[$2], $f00=[$3])     
       |                 |   |                       FilterRel(condition=[AND(=($2, $1), &lt;&gt;($0, $3))])         
       |                 |   |                   ----- JoinRel(condition=[true], joinType=[inner])             
       |                 |   |                   |         TableAccessRel(table=[[LOCALDB, SALES, DEPTS2]])      
       |                 |   |                   |    ---  JoinRel(condition=[true], joinType=[inner])           
       |                 |   |                   |    |        AggregateRel(groupCount=[1])                        
       |                 |   |                   |    |             ProjectRel($f0=[$1])                              
       |                 |   |                   |    |                 TableAccessRel(table=[[LOCALDB, SALES, DEPTS]]) 
       |                 |   |                   |    |       AggregateRel(groupCount=[1])                        
       |                 |   |                   |    |            ProjectRel($f0=[$0])                              
       |                 |   ---                |--  ---              TableAccessRel(table=[[LOCALDB, SALES, EMPS]])  
       |                 |       AggregateRel(groupCount=[1])                                        
       |                 |            ProjectRel($f0=[$2])                                              
       -----            ---          TableAccessRel(table=[[LOCALDB, SALES, EMPS]])
</pre>
<h2> <span class="mw-headline" id="NULL_Semantics">NULL Semantics</span></h2>
<p>For IN predicates, a null value belongs neither to the set returned by the subquery nor to the complement of that set.  Because an IN subquery is translated to an inner join which does not match nulls against any value, this semantics is preserved. However, when translating NOT IN query into logical representation, special filters must be added so that a null value does not qualify the NOT IN condition. For example, "find all employees who do not work for any department in the depts table",
</p>
<pre>       Q13
       select empno
       from emps
       where deptno NOT IN (select deptno from depts)
</pre>
<p>has the following logical plan:
</p>
<pre>
        ProjectRel(NAME=[$1], EMPNO=[$0])
            FilterRel(condition=[NOT(IS TRUE($12))])
               FilterRel(condition=[IS NOT NULL($10)])
                  JoinRel(condition=[=($10, $11)], joinType=[left])
                     ProjectRel([$0...9] = {inputs}, DEPTNO=[$2])
                     TableAccessRel(table=[[LOCALDB, SALES, EMPS]])
                         AggregateRel(groupCount=[1], agg#0=[MIN(1)])
                              ProjectRel($f0=[$0], $f1=[true])
                                  ProjectRel(DEPTNO=[$0])
                                      TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])
</pre>
<p>Left outer joins include null keys on the left in the non joining set, which are rows satisfying the condition "NOT(IS TRUE($12))". The second filter "IS NOT NULL($10)" removes those nulls from this set. The remaining non joining set is the result set.
</p>
<h2> <span class="mw-headline" id="Reducing_Non-Correlated_Subqueries_To_Constants">Reducing Non-Correlated Subqueries To Constants</span></h2>
<p>Scalar, non-correlated subqueries always evaluate to a single, constant value.  Therefore, LucidDB, by default, evaluates the subquery during optimization time, and replaces the subquery with the resulting constant.  If the converted non-correlated subquery is contained in the WHERE clause of a query, this can result in improved query performance because it allows for more efficient processing of the filter. For example, if the filter is on an indexed column, the index can now be used to process the filter. Or, even if there is no index, the filter can be pushed down to the row scan, avoiding the need to invoke the calculator to process the filter.
</p><p>When EXPLAIN PLAN is run on the query, the conversion is not explicitly done, but it is reflected in the plan as follows:
</p>
<pre>
explain plan without implementation for
select * from emps
   where deptno = (select min(deptno) from depts);

'column0'
'ProjectRel(EMPNO=[$0], NAME=[$1], DEPTNO=[$2], GENDER=[$3], CITY=[$4], EMPID=[$5], AGE=[$6], PUBLIC_KEY=[$7], SLACKER=[$8], MANAGER=[$9])'
'  FilterRel(condition=[=($2,&#160;?0)])'
'    TableAccessRel(table=[[LOCALDB, SALES, EMPS]])'
</pre>
<p>Note the <b>?</b> in the <b>FilterRel</b> condition. This is a dynamic parameter that corresponds to the subquery result. The dynamic parameter only appears in the EXPLAIN output as a a placeholder for the subquery result. During the actual execution of the query, dynamic parameters play no role. I.e., rather than displaying the result of the scalar subquery (which would not be possible if at the time EXPLAIN is run, the subquery returns more than one row), we instead just use the dynamic parameter to indicate that the subquery will be replaced with a constant if the query were to be executed.
</p><p>This optimization will also be done for EXISTS expressions on non-correlated subqueries. In this case, the subquery does not have to be a scalar subquery. It's simply evaluated and replaced with a boolean constant indicating whether the subquery returned zero, or one or more rows. In the case of the former, the boolean is set to false, and in the case of the latter, it's set to true. The EXPLAIN output would look like the following:
</p>
<pre>
explain plan without implementation for
select name from emps where exists (select * from depts);

'column0'
'ProjectRel(NAME=[$1])'
'  FilterRel(condition=[?0])'
'    TableAccessRel(table=[[LOCALDB, SALES, EMPS]])'
</pre>
<p>Again, the <b>?0</b> in the <b>FilterRel</b> condition is merely a placeholder dynamic parameter corresponding to the boolean literal. The actual query plan will not contain this dynamic parameter. Note also that at runtime, the optimizer will perform additional reductions for queries like the one above. Specifically, if the subquery returns no rows, then there's no need to execute the outer query.
</p><p>These optimizations do not apply when the subquery contains dynamic parameters.  To completely disable them, run
</p>
<pre>
alter session set &quot;reduceNonCorrelatedSubqueries&quot; = false;
</pre>
<h2> <span class="mw-headline" id="Enforcing_Scalar_Subquery_During_Execution">Enforcing Scalar Subquery During Execution</span></h2>
<p>Scalar subquery is a property (or rather, a constraint) detected during sql translation, and can only be checked when the subquery is evaluated, as it depends on the input data set.  You normally won't be able to see this in the query plan because the scalar subquery is replaced with a dynamic parameter, as noted in the previous section.  But if you were to disable subquery reduction, the plan will have the special aggregate <b>SINGLE_VALUE()</b>, which throws an exception if the aggregate sees multiple input rows:
</p>
<pre>
        ProjectRel(EMPNO=[$0])
           FilterRel(condition=[=($6, $10)])
              JoinRel(condition=[true], joinType=[left])
                TableAccessRel(table=[[LOCALDB, SALES, EMPS]])
                AggregateRel(groupCount=[0], agg#0=[SINGLE_VALUE(0)])
                    ProjectRel(AGE=[$6])
                    TableAccessRel(table=[[LOCALDB, SALES, EMPS]])
</pre>
<h1> <span class="mw-headline" id="Efficient_Decorrelation">Efficient Decorrelation</span></h1>
<p>The generic decorrelation algorithm using value generators can result in suboptimal plans (<a href="#More_Complex_Examples">Examples here</a>). In essence the algorithm inner joins all the outer relations (the "value generators") with the subquery that references them to produce all the qualifying rows (forming the "lookup table"), which is then outer joined with the outer relation to produce the result set that might be further filtered. A minimum of two joins with the outer relation are required per subquery. When the outer query result set is big, or if there are nested correlations, the joins can take up a significant amount of time. However, it is possible to cut down the number of joins. Depending on the types of correlated references, and the property of the relations in the subquery and outer query, certain subqueries can be the "lookup" tables themselves and can be evaluated with just one join with the outer query, eliminating the join with the "value generator". LucidDB recognizes some of these subqueries and transforms them to joins directly.
</p>
<h2> <span class="mw-headline" id="Scalar_Subquery_2">Scalar Subquery</span></h2>
<p>Correlated scalar subquery which projects an expression in its select list.
</p>
<h3> <span class="mw-headline" id="Correlation_in_Projection">Correlation in Projection</span></h3>
<p>A query where the only correlation is in the projected expression.
</p>
<pre>       Q14
       select deptno, (select depts.name from emps)
       from depts;
</pre>
<p>has the following final plan with just one join:
</p>
<pre>
        ProjectRel(DEPTNO=[$0], EXPR$1=[$2])
          ProjectRel(DEPTNO=[$0], NAME=[$1], NAME=[CASE(IS NULL($12), null:$1)])
            JoinRel(condition=[true], joinType=[left])
              FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]])
              AggregateRel(groupCount=[0], agg#0=[SINGLE_VALUE(0)],...agg#10=[SINGLE_VALUE(10)])
                ProjectRel(EMPS.*=[$0..$9], nullIndicator=[true])
                  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]])
</pre>
<h3> <span class="mw-headline" id="Correlation_in_Join_Filter">Correlation in Join Filter</span></h3>
<p>The subquery contains a join filter that references the outer query. There might be correlated reference in the select list also. If the filter conditions are all equality comparisons AND'ed together, and the comparison fields form a unique key for the subquery, as this query below:
</p>
<pre>       Q15
       select deptno, (select emps.name from depts where emps.deptno + 1 = depts.deptno)
       from emps;
</pre>
<p>It has a plan like this one:
</p>
<pre>
        ProjectRel(DEPTNO=[$2], EXPR$1=[$10])
          ProjectRel(EMPS.*=[$0...$9], NAME=[CASE(IS NULL($10), null:$1)])
            JoinRel(condition=[=(+($2, 1), $10)], joinType=[left])
              FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]])
              FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]])
</pre>
<p>Notice the SINGLE_VALUE() aggregates are gone because the uniqueness property of the join key from the subquery. For any outer row, it is guaranteed that the inner query returns at most one row.
</p>
<h2> <span class="mw-headline" id="Scalar_Subquery_with_Aggregates">Scalar Subquery with Aggregates</span></h2>
<p>Correlated scalar subquery which contains aggregates or expressions of aggregates in its select list.
</p>
<h3> <span class="mw-headline" id="Correlation_in_Inputs_to_Aggregates">Correlation in Inputs to Aggregates</span></h3>
<p>The only correlation is in the select list; or more precisely in the input to the aggregate. If the outer query contains a unique key, for example,
</p>
<pre>       Q16
       select deptno, (select count(depts.name) from emps)
       from depts;
</pre>
<p>is evaluated as an aggregate on the unique key over the result of only one join.
</p>
<pre>
        ProjectRel(DEPTNO=[$0], EXPR$1=[$2]
          ProjectRel($f0=[$0], $f1=[$1], $f2=[CAST($2):BIGINT])
            AggregateRel(groupCount=[2], agg#0=[COUNT(3)])
              ProjectRel($f0=[$0], $f1=[$1], $f2=[$1], $f3=[$12])
                JoinRel(condition=[true], joinType=[left])
                  FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]])
                  ProjectRel(EMPS.*=[$0...$9], nullIndicator=[true])
                    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]])
</pre>
<p>Note that the final count is on a generated field "nullIndicator" because count() needs to produce value 0 if the inner query returns an empty set. If the aggregate is sum/min/max, then it will be on the original field. The group by keys are simply all the outer query output fields. In the query above, it is grouping on DEPTS.deptno, DEPTS.name.
</p>
<h3> <span class="mw-headline" id="Correlation_in_Join_Filter_2">Correlation in Join Filter</span></h3>
<p>The subquery contains a join filter that references the outer query. There might be correlated reference in the select list also. If the filter conditions are all equality comparisons AND'ed together, and the comparison fields form a unique key for the outer query, as this query below:
</p>
<pre>       Q17
       select deptno, (select count(depts.name) from emps where emps.deptno = depts.deptno)
       from depts;
</pre>
<p>It has a plan similar to Q16, except for the join condition:
</p>
<pre>
        ProjectRel(DEPTNO=[$0], EXPR$1=[$2])
          ProjectRel($f0=[$0], $f1=[$1], $f2=[CAST($2):BIGINT])
            AggregateRel(groupCount=[2], agg#0=[COUNT(3)])
              ProjectRel($f0=[$0], $f1=[$1], $f2=[$1], $f3=[$12])
                JoinRel(condition=[=($4, $0)], joinType=[left])
                  FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]])
                  ProjectRel(EMPS.*=[$0..$9], nullIndicator=[true])
                    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]])
</pre>
<p>There are other types of correlated subquery that can be rewrritten without using value generators, for example, IN subqueries, EXISTS subqueries. Efficient decorrelation is not implemented for these subquery usages yet.
</p>
<h1> <span class="mw-headline" id="Summary_of_LucidDB_Subquery_Support">Summary of LucidDB Subquery Support</span></h1>
<p>The table below summarizes the subquery support in LucidDB. In addition to the restrictions on decorrelation mentioned in the list, decorrelation is not supported if the correlated variables are used in a subquery that is the operand to any set operation. Multiset operators which are translated to correlated subqueries are not decorrelated, because the translation introduces set operations. Subquery decorrelation uses outer joins (or semi joins). Without outer join support, many decorrelated logical plans cannot be implemented. In LucidDB, all the decorrelated plans are implementable because outer joins and semi joins are supported by hash join.
</p><p>This trace event dumps out the correlated logical plan and the decorrelated plan:
</p>
<pre>       org.eigenbase.sql2rel.level=FINE
</pre>
<p><br />
</p>
<table border="1" cellpadding="4" cellspacing="0" style="border:#c9c9c9 1px solid; margin: 1em 1em 1em 0; border-collapse: collapse;">
<tr>
<th align="Center" style="background:#f0f0f0;" width="200">Subquery Usage/Subquery Type
</th>
<th align="Center" style="background:#f0f0f0;" width="200">scalar, uncorrelated
</th>
<th align="Center" style="background:#f0f0f0;" width="200">scalar, correlated
</th>
<th align="Center" style="background:#f0f0f0;" width="200">table, uncorrelated
</th>
<th align="Center" style="background:#f0f0f0;" width="200">table, correlated
</th></tr>
<tr>
<td> select list </td>
<td> Y </td>
<td> Y </td>
<td> not allowed </td>
<td> not allowed
</td></tr>
<tr>
<td> input to aggregates (including count(distinct ....) </td>
<td> Y </td>
<td> Y </td>
<td> not allowed </td>
<td> not allowed
</td></tr>
<tr>
<td> predicates
</td></tr>
<tr>
<td> comparison with scalar value </td>
<td> Y  except when compared against aggregates in the HAVING clause or when used in the ON clause of joins. Work around is to use WHERE clause if possible. </td>
<td> Y with same restrictions as the uncorrelated scalar subquery. </td>
<td> not allowed </td>
<td> not allowed
</td></tr>
<tr>
<td> <b>Operators testing set properties</b>
</td></tr>
<tr>
<td> IN/NOT IN, EXISTS/NOT EXISTS </td>
<td> N/A </td>
<td> N/A </td>
<td> Y </td>
<td> Y
</td></tr>
<tr>
<td> ANY, ALL, SOME </td>
<td> N/A </td>
<td> N/A </td>
<td> N </td>
<td> N
</td></tr>
<tr>
<td> lateral derived tables </td>
<td> N/A </td>
<td> N/A </td>
<td> Y </td>
<td> Y except that multiset table, which is inherently correlated, is not decorrelated
</td></tr></table>
<h1> <span class="mw-headline" id="Future_Work">Future Work</span></h1>
<p>Subqueries usually can be rewritten into equivalent joins. However, those queries tend to be hard to understand, especially if there are correlations and nested subqueries.         Because a general purpose decorrelation scheme tends to produce poor query plans, as shown in <a href="#LucidDB_Subquery_Rewrite">LucidDB Subquery Rewrite</a>, it is still useful to add execution support for subqueries without decorrelation.
</p><p>During execution of the query plan, the RelNode tree representing the subquery is connected to the main query via a special RelNode(call it "CorrRel"). The subquery part of the CorrRel input is restarted for each fetch of the main RelNode tree, and the subquery tree is evaluated with a new outer query row as the context. This CorrRel needs to support restartable input, as well as passing in the outer query context for each restart. CorrRel fetches from the subquery tree and evaluates the expression that references the subquery, for example, the exists() condition in Q6.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 229/1000000
Post-expand include size: 126/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1667-0!*!*!!en!*!* and timestamp 20140414191050 -->
</div><div class="printfooter">
Retrieved from "<a href="http://luciddb.org/wiki/index.php?title=LucidDbSubqueries&amp;oldid=7131">http://luciddb.org/wiki/index.php?title=LucidDbSubqueries&amp;oldid=7131</a>"</div>
		<div id='catlinks' class='catlinks catlinks-allhidden'></div>		<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
				<li id="ca-nstab-main" class="selected"><a href="/wiki/LucidDbSubqueries" title="View the content page [c]" accesskey="c">Page</a></li>
				<li id="ca-talk" class="new"><a href="/wiki/index.php?title=Talk:LucidDbSubqueries&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				<li id="ca-viewsource"><a href="/wiki/index.php?title=LucidDbSubqueries&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				<li id="ca-history"><a href="/wiki/index.php?title=LucidDbSubqueries&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=LucidDbSubqueries" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a title="Visit the main page" style="background-image: url(http://www.luciddb.org/img/logo.gif);" href="/wiki/LucidDbDocs"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class="generated-sidebar portlet" id="p-Product_Documentation">
		<h5>Product Documentation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-LucidDB-Server"><a href="/wiki/LucidDbDocs">LucidDB Server</a></li>
			</ul>
		</div>
	</div>
	<div class="generated-sidebar portlet" id="p-Eigenbase_Projects">
		<h5>Eigenbase Projects</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Introduction"><a href="/wiki/Eigenbase_Introduction">Introduction</a></li>
				<li id="n-LucidDB-Server"><a href="/wiki/LucidDbDocs">LucidDB Server</a></li>
				<li id="n-Enki-Library"><a href="/wiki/EnkiDocs">Enki Library</a></li>
				<li id="n-Farrago-Engine"><a href="/wiki/FarragoDocs">Farrago Engine</a></li>
				<li id="n-Fennel-Library"><a href="/wiki/FennelDocs">Fennel Library</a></li>
			</ul>
		</div>
	</div>
	<div class="generated-sidebar portlet" id="p-Wiki_Tools">
		<h5>Wiki Tools</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Recent-Page-Updates"><a href="/wiki/Special:RecentChanges">Recent Page Updates</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="The place to find out">Help</a></li>
				<li id="n-sitesupport"><a href="/wiki/Sitesupport-url">sitesupport</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/index.php" id="searchform">
				<input type='hidden' name="title" value="Special:Search"/>
				<input type="search" name="search" title="Search LucidDB Wiki [f]" accesskey="f" id="searchInput" />
				<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />&#160;
				<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />
			</form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/LucidDbSubqueries" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/LucidDbSubqueries" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
				<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
				<li><a href="/wiki/index.php?title=LucidDbSubqueries&amp;printable=yes" rel="alternate">Printable version</a></li>
				<li id="t-permalink"><a href="/wiki/index.php?title=LucidDbSubqueries&amp;oldid=7131" title="Permanent link to this revision of the page">Permanent link</a></li>
			</ul>
		</div>
	</div>
</div><!-- end of the left (by default at least) column -->
<div class="visualClear"></div>
<div id="footer">
	<div id="f-copyrightico">
		<a href="http://www.gnu.org/copyleft/fdl.html"><img src="/wiki/skins/common/images/gnu-fdl.png" alt="GNU Free Documentation License 1.2" width="88" height="31" /></a>
	</div>
	<div id="f-poweredbyico">
		<a href="http://www.mediawiki.org/"><img src="/wiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
	</div>
	<ul id="f-list">
		<li id="lastmod"> This page was last modified on 3 November 2011, at 18:32.</li>
		<li id="viewcount">This page has been accessed 5,170 times.</li>
		<li id="copyright">Content is available under <a class="external" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.2</a>.</li>
		<li id="privacy"><a href="/wiki/LucidDB_Wiki:Privacy_policy" title="LucidDB Wiki:Privacy policy">Privacy policy</a></li>
		<li id="about"><a href="/wiki/LucidDB_Wiki:About" title="LucidDB Wiki:About">About LucidDB Wiki</a></li>
		<li id="disclaimer"><a href="/wiki/LucidDB_Wiki:General_disclaimer" title="LucidDB Wiki:General disclaimer">Disclaimers</a></li>
	</ul>
</div>
</div>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"monobook","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,
	"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: wikidb:resourceloader:filter:minify-js:4:99acc2c3ab516bb21085c70c2195f3df */
}
</script><!-- Piwik -->
<script type="text/javascript">
/* <![CDATA[ */
var pkBaseURL = (("https:" == document.location.protocol) ? "https://http://apps.sourceforge.net/piwik/eigenbase/" : "http://http://apps.sourceforge.net/piwik/eigenbase/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
/* ]]> */
</script>
<script type="text/javascript">
/* <![CDATA[ */
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
piwikTracker.setDocumentTitle("");
piwikTracker.setIgnoreClasses("image");

piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
/* ]]> */
</script><noscript><p><img src="http://http://apps.sourceforge.net/piwik/eigenbase/piwik.php?idsite=1" style="border:0" alt=""/></p></noscript>
<!-- /Piwik --><!-- Served in 0.237 secs. --></body></html>